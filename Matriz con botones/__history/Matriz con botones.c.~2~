#include <16F877a.h>
#device adc=10
#use delay(clock=4000000)
#fuses XT, NOWDT, NOPROTECT, NOBROWNOUT, PUT, NOLVP

#byte PORTB = 0xF81
#byte PORTD = 0xF83
#byte TRISB = 0xF93
#byte TRISD = 0xF95

#define LCD_ENABLE_PIN  PIN_D0
#define LCD_RS_PIN      PIN_D1
#define LCD_RW_PIN      PIN_D2
#define LCD_DATA4       PIN_D4
#define LCD_DATA5       PIN_D5
#define LCD_DATA6       PIN_D6
#define LCD_DATA7       PIN_D7

#include <lcd.c>

void init_keypad() {
    TRISB = 0xF0; // Los 4 bits más altos (filas) como entradas y los 4 bits más bajos (columnas) como salidas
    PORTB = 0x0F; // Inicializa las columnas en bajo (podría variar según tu configuración)
}

char read_keypad() {
    const char keys[4][4] = {
        {'1', '2', '3', 'A'},
        {'4', '5', '6', 'B'},
        {'7', '8', '9', 'C'},
        {'*', '0', '#', 'D'}
    };
    char row, col;

    for (col = 0; col < 4; col++) {
        PORTB = ~(0x01 << col); // Habilita la columna actual

        for (row = 0; row < 4; row++) {
            if (!(PORTB & (0x10 << row))) { // Verifica si alguna fila está en bajo
                delay_ms(20); // Debounce
                while (!(PORTB & (0x10 << row))); // Espera a que la tecla sea liberada
                return keys[row][col];
            }
        }
    }

    return '\0'; // No key pressed
}

void main() {
    char key;

    lcd_init();
    init_keypad();

    while (true) {
        key = read_keypad();
        if (key != '\0') {
            lcd_putc("\f"); // Limpia la pantalla
            lcd_putc("Tecla: ");
            lcd_putc(key);
            delay_ms(500); // Para visualizar la tecla presionada antes de limpiar la pantalla
        }
    }
}

